# 1. manager
## 1.1 cmd/main.go
```go
// manager 核心数据对象
	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme:                 scheme,
		Metrics:                metricsServerOptions,
		WebhookServer:          webhookServer,
		HealthProbeBindAddress: probeAddr,
		LeaderElection:         enableLeaderElection,
		LeaderElectionID:       "d24078e2.jeff",
		// LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily
		// when the Manager ends. This requires the binary to immediately end when the
		// Manager is stopped, otherwise, this setting is unsafe. Setting this significantly
		// speeds up voluntary leader transitions as the new leader don't have to wait
		// LeaseDuration time first.
		//
		// In the default scaffold provided, the program ends immediately after
		// the manager stops, so would be fine to enable this option. However,
		// if you are doing or is intended to do any operation such as perform cleanups
		// after the manager stops then its usage might be unsafe.
		// LeaderElectionReleaseOnCancel: true,
	})
	if err != nil {
		setupLog.Error(err, "unable to start manager")
		os.Exit(1)
	}
```
## 1.2  ./vendor/sigs.k8s.io/controller-runtime/alias.go
```go
// NewManager returns a new Manager for creating Controllers.
// Note that if ContentType in the given config is not set, "application/vnd.kubernetes.protobuf"
// will be used for all built-in resources of Kubernetes, and "application/json" is for other types
// including all CRD resources.
NewManager = manager.New
```
## 1.3 ./vendor/sigs.k8s.io/controller-runtime/pkg/manager/manager.go
创建一个完整的 controller-manager 实例（实现 Manager 接口），也就是 operator 的“核心运行体
```text
┌────────────────────────────┐
│      controllerManager     │
│                            │
│  ┌────────────┐            │
│  │  cluster   │◄──────────┐│
│  └────────────┘            │
│  ┌────────────┐            │
│  │  cache     │◄────┐      │
│  └────────────┘     │      │
│  ┌────────────┐     │      │
│  │  client    │◄────┘      │
│  └────────────┘            │
│  ┌──────────────────────┐  │
│  │  metricsServer       │  │
│  └──────────────────────┘  │
│  ┌──────────────────────┐  │
│  │  healthProbeListener │  │
│  └──────────────────────┘  │
│  ┌──────────────────────┐  │
│  │  leader election     │◄─┼─┐
│  └──────────────────────┘  │ │
│  ┌──────────────────────┐  │ │
│  │  pprof listener      │  │ │
│  └──────────────────────┘  │ │
└────────────────────────────┘ │
               ▲                │
               └────────────────┘
```
```go
// New returns a new Manager for creating Controllers.
// Note that if ContentType in the given config is not set, "application/vnd.kubernetes.protobuf"
// will be used for all built-in resources of Kubernetes, and "application/json" is for other types
// including all CRD resources.
func New(config *rest.Config, options Options) (Manager, error) {
	if config == nil {
		return nil, errors.New("must specify Config")
	}
	// Set default values for options fields 设置一些默认的选项，可能包含一些默认的方法
	options = setOptionsDefaults(options)

	// 创建cluster，client和cache属于cluster，里面会包含一些与cluster通信的必要组件
	cluster, err := cluster.New(config, func(clusterOptions *cluster.Options) {
		clusterOptions.Scheme = options.Scheme
		clusterOptions.MapperProvider = options.MapperProvider
		clusterOptions.Logger = options.Logger
		clusterOptions.NewCache = options.NewCache
		clusterOptions.NewClient = options.NewClient
		clusterOptions.Cache = options.Cache
		clusterOptions.Client = options.Client
		clusterOptions.EventBroadcaster = options.EventBroadcaster //nolint:staticcheck
	})
	if err != nil {
		return nil, err
	}

	config = rest.CopyConfig(config)
	if config.UserAgent == "" {
		config.UserAgent = rest.DefaultKubernetesUserAgent()
	}

	// Create the recorder provider to inject event recorders for the components.
	// TODO(directxman12): the log for the event provider should have a context (name, tags, etc) specific
	// to the particular controller that it's being injected into, rather than a generic one like is here.
	// 创建一个记录器
	recorderProvider, err := options.newRecorderProvider(config, cluster.GetHTTPClient(), cluster.GetScheme(), options.Logger.WithName("events"), options.makeBroadcaster)
	if err != nil {
		return nil, err
	}

	// 集群调度相关的数据
	// Create the resource lock to enable leader election)
	var leaderConfig *rest.Config
	var leaderRecorderProvider *intrec.Provider

	if options.LeaderElectionConfig == nil {
		leaderConfig = rest.CopyConfig(config)
		leaderRecorderProvider = recorderProvider
	} else {
		leaderConfig = rest.CopyConfig(options.LeaderElectionConfig)
		scheme := cluster.GetScheme()
		err := corev1.AddToScheme(scheme)
		if err != nil {
			return nil, err
		}
		err = coordinationv1.AddToScheme(scheme)
		if err != nil {
			return nil, err
		}
		httpClient, err := rest.HTTPClientFor(options.LeaderElectionConfig)
		if err != nil {
			return nil, err
		}
		leaderRecorderProvider, err = options.newRecorderProvider(leaderConfig, httpClient, scheme, options.Logger.WithName("events"), options.makeBroadcaster)
		if err != nil {
			return nil, err
		}
	}

	var resourceLock resourcelock.Interface
	if options.LeaderElectionResourceLockInterface != nil && options.LeaderElection {
		resourceLock = options.LeaderElectionResourceLockInterface
	} else {
		resourceLock, err = options.newResourceLock(leaderConfig, leaderRecorderProvider, leaderelection.Options{
			LeaderElection:             options.LeaderElection,
			LeaderElectionResourceLock: options.LeaderElectionResourceLock,
			LeaderElectionID:           options.LeaderElectionID,
			LeaderElectionNamespace:    options.LeaderElectionNamespace,
			RenewDeadline:              *options.RenewDeadline,
		})
		if err != nil {
			return nil, err
		}
	}
	// Create the metrics server.
	metricsServer, err := options.newMetricsServer(options.Metrics, config, cluster.GetHTTPClient())
	if err != nil {
		return nil, err
	}

	// Create health probes listener. This will throw an error if the bind
	// address is invalid or already in use.
	healthProbeListener, err := options.newHealthProbeListener(options.HealthProbeBindAddress)
	if err != nil {
		return nil, err
	}

	// Create pprof listener. This will throw an error if the bind
	// address is invalid or already in use.
	pprofListener, err := options.newPprofListener(options.PprofBindAddress)
	if err != nil {
		return nil, fmt.Errorf("failed to new pprof listener: %w", err)
	}

	errChan := make(chan error, 1)
	runnables := newRunnables(options.BaseContext, errChan)
	return &controllerManager{
		stopProcedureEngaged:          ptr.To(int64(0)),
		cluster:                       cluster,
		runnables:                     runnables,
		errChan:                       errChan,
		recorderProvider:              recorderProvider,
		resourceLock:                  resourceLock,
		metricsServer:                 metricsServer,
		controllerConfig:              options.Controller,
		logger:                        options.Logger,
		elected:                       make(chan struct{}),
		webhookServer:                 options.WebhookServer,
		leaderElectionID:              options.LeaderElectionID,
		leaseDuration:                 *options.LeaseDuration,
		renewDeadline:                 *options.RenewDeadline,
		retryPeriod:                   *options.RetryPeriod,
		healthProbeListener:           healthProbeListener,
		readinessEndpointName:         options.ReadinessEndpointName,
		livenessEndpointName:          options.LivenessEndpointName,
		pprofListener:                 pprofListener,
		gracefulShutdownTimeout:       *options.GracefulShutdownTimeout,
		internalProceduresStop:        make(chan struct{}),
		leaderElectionStopped:         make(chan struct{}),
		leaderElectionReleaseOnCancel: options.LeaderElectionReleaseOnCancel,
	}, nil
}
```
